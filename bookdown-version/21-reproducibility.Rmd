---
title: ''
output: html_document
---

## Reproducibile {#reproduce}

### Manage project dependencies {#projdep}
Previously packrat was more widely used, but lots of people seem to use conda now.  
* [Conda][1]  
* [Packrat][2]  
* [Renv][3]

[1]:https://github.com/moj-analytical-services/coffee-and-coding-public/blob/master/2019-10-30%20Conda/conda.pdf
[2]:https://rstudio.github.io/packrat/
[3]:https://blog.rstudio.com/2019/11/06/renv-project-environments-for-r/

### Optimize for change {#change}
* Don’t try to solve every conceivable problem up-front, instead focus on making your code easy to change when needed.
* Don’t prematurely optimize - choose clarity over performance, unless there is a serious performance issue that needs to be addressed.
* Change can come in several forms, including hardware - your code will eventually be run on a colleague's machine or a server somewhere.  Without overcomplicating things, write your code with this in mind.  For example, use relative paths (e.g. `./file_in_the_project_directory.R` rather than `/Users/my_username/development/my_project/file_in_the_project_directory.R`)


### Reproducing on another machine {#githash}
#### Include a git hash {-}

Some tips on making your analyses simple to reproduce

If practical, the output of your code should include the git hash
of the code that produced it. By doing so, the analysis should be
more reproducible, there is no ambiguity about the specific code 
that was used to generate it.

##### R {-}
You can access the git hash using either of the following code:
snippets.
```{r}
library(git2r)

repo <- repository(".")
print(head(repo))
```

or

```{r}
print(system("git rev-parse --short HEAD", intern = TRUE))
```

##### Python {-}
You can access the git hash using the following code:
```import subprocess

def get_git_revision_hash():
    return subprocess.check_output(['git', 'rev-parse', 'HEAD'])

def get_git_revision_short_hash():
    return subprocess.check_output(['git', 'rev-parse', '--short', 'HEAD'])```
